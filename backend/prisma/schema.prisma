generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Album {
  id               String                   @id @default(cuid())
  rgMbid           String                   @unique
  artistId         String
  title            String
  year             Int?
  coverUrl         String?
  primaryType      String
  label            String?
  genres           Json?
  lastSynced       DateTime                 @default(now())
  location         AlbumLocation            @default(LIBRARY)
  searchVector     Unsupported("tsvector")?
  displayTitle     String?
  displayYear      Int?
  hasUserOverrides Boolean                  @default(false)
  userCoverUrl     String?
  userGenres       Json?
  originalYear     Int?
  artist           Artist                   @relation(fields: [artistId], references: [id], onDelete: Cascade)
  tracks           Track[]
}

model ApiKey {
  id        String   @id @default(cuid())
  userId    String
  key       String   @unique
  name      String
  lastUsed  DateTime @default(now())
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Artist {
  id                  String                   @id @default(cuid())
  mbid                String                   @unique
  name                String
  normalizedName      String                   @default("")
  summary             String?
  heroUrl             String?
  genres              Json?
  lastSynced          DateTime                 @default(now())
  lastEnriched        DateTime?
  enrichmentStatus    String                   @default("pending")
  searchVector        Unsupported("tsvector")?
  similarArtistsJson  Json?
  displayName         String?
  hasUserOverrides    Boolean                  @default(false)
  userGenres          Json?
  userHeroUrl         String?
  userSummary         String?
  countsLastUpdated   DateTime?
  discoveryAlbumCount Int                      @default(0)
  libraryAlbumCount   Int                      @default(0)
  totalTrackCount     Int                      @default(0)
  albums              Album[]
  ownedAlbums         OwnedAlbum[]
  similarFrom         SimilarArtist[]          @relation("FromArtist")
  similarTo           SimilarArtist[]          @relation("ToArtist")
}

model Audiobook {
  id             String                   @id @default(cuid())
  title          String
  author         String?
  narrator       String?
  description    String?
  publishedYear  Int?
  publisher      String?
  series         String?
  seriesSequence String?
  duration       Float?
  numTracks      Int?
  numChapters    Int?
  size           BigInt?
  isbn           String?
  asin           String?
  language       String?
  genres         String[]
  tags           String[]
  localCoverPath String?
  coverUrl       String?
  audioUrl       String
  libraryId      String?
  createdAt      DateTime                 @default(now())
  updatedAt      DateTime                 @updatedAt
  lastSyncedAt   DateTime                 @default(now())
  searchVector   Unsupported("tsvector")?
}

model AudiobookProgress {
  id               String   @id @default(cuid())
  userId           String
  audiobookshelfId String
  title            String
  author           String?
  coverUrl         String?
  currentTime      Float    @default(0)
  duration         Float    @default(0)
  isFinished       Boolean  @default(false)
  lastPlayedAt     DateTime @default(now())
  updatedAt        DateTime @updatedAt
  createdAt        DateTime @default(now())
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, audiobookshelfId])
}

model CachedTrack {
  id             String   @id @default(cuid())
  userId         String
  trackId        String
  localPath      String
  quality        String
  fileSizeMb     Float
  cachedAt       DateTime @default(now())
  lastAccessedAt DateTime @default(now())
  track          Track    @relation(fields: [trackId], references: [id], onDelete: Cascade)
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, trackId, quality])
}

model DeviceLinkCode {
  id         String    @id @default(cuid())
  code       String    @unique
  userId     String
  expiresAt  DateTime
  usedAt     DateTime?
  deviceName String?
  apiKeyId   String?
  createdAt  DateTime  @default(now())
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model DiscoverExclusion {
  id              String   @id @default(cuid())
  userId          String
  albumMbid       String
  artistName      String?
  albumTitle      String?
  lastSuggestedAt DateTime @default(now())
  expiresAt       DateTime
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, albumMbid])
}

model DiscoveryAlbum {
  id            String           @id @default(cuid())
  userId        String
  rgMbid        String
  artistName    String
  artistMbid    String?
  albumTitle    String
  lidarrAlbumId Int?
  downloadedAt  DateTime?
  folderPath    String           @default("")
  weekStartDate DateTime
  weekEndDate   DateTime         @default(now())
  status        DiscoverStatus   @default(ACTIVE)
  likedAt       DateTime?
  similarity    Float?
  tier          String?
  user          User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  tracks        DiscoveryTrack[]

  @@unique([userId, weekStartDate, rgMbid])
}

model DiscoveryBatch {
  id              String        @id @default(cuid())
  userId          String
  weekStart       DateTime
  targetSongCount Int
  status          String        @default("downloading")
  totalAlbums     Int           @default(0)
  completedAlbums Int           @default(0)
  failedAlbums    Int           @default(0)
  finalSongCount  Int           @default(0)
  logs            Json?
  errorMessage    String?
  createdAt       DateTime      @default(now())
  completedAt     DateTime?
  version         Int           @default(0)
  jobs            DownloadJob[]
}

model DiscoveryTrack {
  id               String         @id @default(cuid())
  discoveryAlbumId String
  trackId          String?
  fileName         String
  filePath         String
  inPlaylistCount  Int            @default(0)
  userKept         Boolean        @default(false)
  lastPlayedAt     DateTime?
  discoveryAlbum   DiscoveryAlbum @relation(fields: [discoveryAlbumId], references: [id], onDelete: Cascade)
}

model DislikedEntity {
  id         String   @id @default(cuid())
  userId     String
  entityType String
  entityId   String
  dislikedAt DateTime @default(now())
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, entityType, entityId])
}

model DownloadJob {
  id               String          @id @default(cuid())
  correlationId    String?         @unique
  userId           String
  subject          String
  type             String
  targetMbid       String
  status           String
  error            String?
  lidarrRef        String?
  lidarrAlbumId    Int?
  metadata         Json?
  attempts         Int             @default(0)
  startedAt        DateTime?
  completedAt      DateTime?
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  discoveryBatchId String?
  triedReleases    String[]        @default([])
  releaseIndex     Int             @default(0)
  artistMbid       String?
  cleared          Boolean         @default(false)
  discoveryBatch   DiscoveryBatch? @relation(fields: [discoveryBatchId], references: [id])
  user             User            @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model EnrichmentFailure {
  id            String    @id @default(cuid())
  entityType    String
  entityId      String
  entityName    String?
  errorMessage  String?
  errorCode     String?
  retryCount    Int       @default(0)
  maxRetries    Int       @default(3)
  firstFailedAt DateTime  @default(now())
  lastFailedAt  DateTime  @default(now())
  skipped       Boolean   @default(false)
  skippedAt     DateTime?
  resolved      Boolean   @default(false)
  resolvedAt    DateTime?
  metadata      Json?

  @@unique([entityType, entityId])
  @@index([entityType, resolved])
  @@index([lastFailedAt])
  @@index([skipped])
}

model Genre {
  id          String       @id @default(cuid())
  name        String       @unique
  trackGenres TrackGenre[]
}

model HiddenPlaylist {
  id         String   @id @default(cuid())
  userId     String
  playlistId String
  createdAt  DateTime @default(now())
  playlist   Playlist @relation(fields: [playlistId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, playlistId])
}

model LikedTrack {
  userId  String
  trackId String
  likedAt DateTime @default(now())
  track   Track    @relation(fields: [trackId], references: [id], onDelete: Cascade)
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, trackId])
}

model ListeningState {
  id         String   @id @default(cuid())
  userId     String
  kind       String
  entityId   String
  trackId    String?
  positionMs Int      @default(0)
  updatedAt  DateTime @updatedAt
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, kind, entityId])
}

model MoodBucket {
  id        String   @id @default(cuid())
  trackId   String
  mood      String
  score     Float
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  track     Track    @relation(fields: [trackId], references: [id], onDelete: Cascade)

  @@unique([trackId, mood])
}

model Notification {
  id        String   @id @default(cuid())
  userId    String
  type      String
  title     String
  message   String?
  metadata  Json?
  read      Boolean  @default(false)
  cleared   Boolean  @default(false)
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model OwnedAlbum {
  artistId String
  rgMbid   String
  source   String
  artist   Artist @relation(fields: [artistId], references: [id], onDelete: Cascade)

  @@id([artistId, rgMbid])
}

model Play {
  id       String       @id @default(cuid())
  userId   String
  trackId  String
  playedAt DateTime     @default(now())
  source   ListenSource @default(LIBRARY)
  track    Track        @relation(fields: [trackId], references: [id], onDelete: Cascade)
  user     User         @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model PlaybackState {
  userId       String   @id
  playbackType String
  trackId      String?
  audiobookId  String?
  podcastId    String?
  queue        Json?
  currentIndex Int      @default(0)
  isShuffle    Boolean  @default(false)
  updatedAt    DateTime @updatedAt
  createdAt    DateTime @default(now())
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Playlist {
  id                 String                 @id @default(cuid())
  userId             String
  mixId              String?
  name               String
  isPublic           Boolean                @default(false)
  createdAt          DateTime               @default(now())
  spotifyPlaylistId  String?
  spotifyPlaylistUrl String?
  user               User                   @relation(fields: [userId], references: [id], onDelete: Cascade)
  items              PlaylistItem[]
  pendingTracks      PlaylistPendingTrack[]
  hiddenByUsers      HiddenPlaylist[]

  @@unique([userId, mixId])
}

model PlaylistItem {
  id         String   @id @default(cuid())
  playlistId String
  trackId    String
  sort       Int
  playlist   Playlist @relation(fields: [playlistId], references: [id], onDelete: Cascade)
  track      Track    @relation(fields: [trackId], references: [id], onDelete: Cascade)

  @@unique([playlistId, trackId])
}

model PlaylistPendingTrack {
  id               String   @id @default(cuid())
  playlistId       String
  spotifyArtist    String
  spotifyTitle     String
  spotifyAlbum     String
  albumMbid        String?
  artistMbid       String?
  deezerPreviewUrl String?
  sort             Int
  createdAt        DateTime @default(now())
  playlist         Playlist @relation(fields: [playlistId], references: [id], onDelete: Cascade)

  @@unique([playlistId, spotifyArtist, spotifyTitle])
}

model Podcast {
  id              String                   @id @default(cuid())
  feedUrl         String                   @unique
  title           String
  author          String?
  description     String?
  imageUrl        String?
  localCoverPath  String?
  itunesId        String?                  @unique
  language        String?
  explicit        Boolean                  @default(false)
  episodeCount    Int                      @default(0)
  lastRefreshed   DateTime                 @default(now())
  refreshInterval Int                      @default(3600)
  autoRefresh     Boolean                  @default(true)
  createdAt       DateTime                 @default(now())
  updatedAt       DateTime                 @updatedAt
  searchVector    Unsupported("tsvector")?
  episodes        PodcastEpisode[]
  subscriptions   PodcastSubscription[]
}

model PodcastDownload {
  id             String         @id @default(cuid())
  userId         String
  episodeId      String
  localPath      String
  fileSizeMb     Float
  downloadedAt   DateTime       @default(now())
  lastAccessedAt DateTime       @default(now())
  episode        PodcastEpisode @relation(fields: [episodeId], references: [id], onDelete: Cascade)
  user           User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, episodeId])
}

model PodcastEpisode {
  id             String                   @id @default(cuid())
  podcastId      String
  guid           String
  title          String
  description    String?
  audioUrl       String
  duration       Int                      @default(0)
  publishedAt    DateTime
  episodeNumber  Int?
  season         Int?
  imageUrl       String?
  localCoverPath String?
  fileSize       Int?
  mimeType       String?                  @default("audio/mpeg")
  createdAt      DateTime                 @default(now())
  searchVector   Unsupported("tsvector")?
  podcast        Podcast                  @relation(fields: [podcastId], references: [id], onDelete: Cascade)
  progress       PodcastProgress[]
  downloads      PodcastDownload[]

  @@unique([podcastId, guid])
}

model PodcastProgress {
  id           String         @id @default(cuid())
  userId       String
  episodeId    String
  currentTime  Float          @default(0)
  duration     Float          @default(0)
  isFinished   Boolean        @default(false)
  lastPlayedAt DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  createdAt    DateTime       @default(now())
  episode      PodcastEpisode @relation(fields: [episodeId], references: [id], onDelete: Cascade)
  user         User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, episodeId])
}

model PodcastSubscription {
  userId       String
  podcastId    String
  subscribedAt DateTime @default(now())
  podcast      Podcast  @relation(fields: [podcastId], references: [id], onDelete: Cascade)
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, podcastId])
}

model SimilarArtist {
  fromArtistId String
  toArtistId   String
  weight       Float  @default(1.0)
  fromArtist   Artist @relation("FromArtist", fields: [fromArtistId], references: [id], onDelete: Cascade)
  toArtist     Artist @relation("ToArtist", fields: [toArtistId], references: [id], onDelete: Cascade)

  @@id([fromArtistId, toArtistId])
}

model SpotifyImportJob {
  id                 String   @id @default(cuid())
  userId             String
  spotifyPlaylistId  String
  playlistName       String
  status             String
  progress           Int      @default(0)
  albumsTotal        Int
  albumsCompleted    Int      @default(0)
  tracksTotal        Int
  tracksMatched      Int      @default(0)
  tracksDownloadable Int      @default(0)
  createdPlaylistId  String?
  error              String?
  pendingTracks      Json
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  user               User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model SystemSettings {
  id                          String   @id @default("default")
  lidarrEnabled               Boolean  @default(true)
  lidarrUrl                   String?  @default("http://localhost:8686")
  lidarrApiKey                String?
  openaiEnabled               Boolean  @default(false)
  openaiApiKey                String?
  openaiModel                 String?  @default("gpt-4")
  openaiBaseUrl               String?
  fanartEnabled               Boolean  @default(false)
  fanartApiKey                String?
  audiobookshelfEnabled       Boolean  @default(false)
  audiobookshelfUrl           String?  @default("http://localhost:13378")
  audiobookshelfApiKey        String?
  soulseekUsername            String?
  soulseekPassword            String?
  spotifyClientId             String?
  spotifyClientSecret         String?
  musicPath                   String?  @default("/music")
  downloadPath                String?  @default("/downloads")
  autoSync                    Boolean  @default(true)
  autoEnrichMetadata          Boolean  @default(true)
  maxConcurrentDownloads      Int      @default(3)
  downloadRetryAttempts       Int      @default(3)
  transcodeCacheMaxGb         Int      @default(10)
  downloadSource              String   @default("soulseek")
  primaryFailureFallback      String   @default("none")
  updatedAt                   DateTime @updatedAt
  createdAt                   DateTime @default(now())
  enrichmentConcurrency       Int      @default(1)
  lidarrWebhookSecret         String?
  audioAnalyzerWorkers        Int      @default(2)
  clapWorkers                 Int      @default(2)
  lastfmApiKey                String?
  soulseekConcurrentDownloads Int      @default(4)
  soulseekEnabled             Boolean?
  soulseekDownloadPath        String?
  lastfmApiSecret             String?
  lastfmUserKey               String?
  lastfmEnabled               Boolean?
}

model Track {
  id                          String                   @id @default(cuid())
  albumId                     String
  title                       String
  trackNo                     Int
  duration                    Int
  mime                        String?
  searchVector                Unsupported("tsvector")?
  filePath                    String                   @unique
  fileModified                DateTime
  fileSize                    Int
  bpm                         Float?
  beatsCount                  Int?
  key                         String?
  keyScale                    String?
  keyStrength                 Float?
  energy                      Float?
  loudness                    Float?
  dynamicRange                Float?
  danceability                Float?
  valence                     Float?
  arousal                     Float?
  instrumentalness            Float?
  acousticness                Float?
  speechiness                 Float?
  moodHappy                   Float?
  moodSad                     Float?
  moodRelaxed                 Float?
  moodAggressive              Float?
  moodParty                   Float?
  moodAcoustic                Float?
  moodElectronic              Float?
  danceabilityMl              Float?
  moodTags                    String[]
  essentiaGenres              String[]
  lastfmTags                  String[]
  analysisStatus              String                   @default("pending")
  analysisVersion             String?
  analysisMode                String?
  analyzedAt                  DateTime?
  analysisError               String?
  analysisRetryCount          Int                      @default(0)
  updatedAt                   DateTime                 @updatedAt
  displayTitle                String?
  displayTrackNo              Int?
  hasUserOverrides            Boolean                  @default(false)
  analysisStartedAt           DateTime?
  vibeAnalysisStatus          String?
  vibeAnalysisStartedAt       DateTime?
  vibeAnalysisError           String?
  vibeAnalysisRetryCount      Int                      @default(0)
  vibeAnalysisStatusUpdatedAt DateTime?
  album                       Album                    @relation(fields: [albumId], references: [id], onDelete: Cascade)
  cachedBy                    CachedTrack[]
  likedBy                     LikedTrack[]
  moodBuckets                 MoodBucket[]
  plays                       Play[]
  playlistItems               PlaylistItem[]
  trackGenres                 TrackGenre[]
  transcodedFiles             TranscodedFile[]
  trackEmbedding              TrackEmbedding?
}

model TrackGenre {
  trackId String
  genreId String
  track   Track  @relation(fields: [trackId], references: [id], onDelete: Cascade)
  genre   Genre  @relation(fields: [genreId], references: [id], onDelete: Cascade)

  @@id([trackId, genreId])
}

model TranscodedFile {
  id             String   @id @default(cuid())
  trackId        String
  quality        String
  cachePath      String   @unique
  cacheSize      Int
  sourceModified DateTime
  lastAccessed   DateTime @default(now())
  createdAt      DateTime @default(now())
  track          Track    @relation(fields: [trackId], references: [id], onDelete: Cascade)
}

model UnavailableAlbum {
  id              String   @id @default(cuid())
  userId          String
  artistName      String
  albumTitle      String
  albumMbid       String
  artistMbid      String?
  similarity      Float
  tier            String
  weekStartDate   DateTime
  previewUrl      String?
  deezerTrackId   String?
  deezerAlbumId   String?
  attemptNumber   Int      @default(0)
  originalAlbumId String?
  createdAt       DateTime @default(now())
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, weekStartDate, albumMbid])
}

model User {
  id                     String                @id @default(cuid())
  username               String                @unique
  passwordHash           String
  role                   String                @default("user")
  onboardingComplete     Boolean               @default(false)
  enrichmentSettings     Json?
  twoFactorEnabled       Boolean               @default(false)
  twoFactorSecret        String?
  twoFactorRecoveryCodes String?
  moodMixParams          Json?
  tokenVersion           Int                   @default(0)
  createdAt              DateTime              @default(now())
  apiKeys                ApiKey[]
  audiobookProgress      AudiobookProgress[]
  cachedTracks           CachedTrack[]
  deviceLinkCodes        DeviceLinkCode[]
  discoverExclusions     DiscoverExclusion[]
  discoveryAlbums        DiscoveryAlbum[]
  dislikedEntities       DislikedEntity[]
  downloadJobs           DownloadJob[]
  hiddenPlaylists        HiddenPlaylist[]
  likedTracks            LikedTrack[]
  listeningState         ListeningState[]
  notifications          Notification[]
  plays                  Play[]
  playbackState          PlaybackState?
  playlists              Playlist[]
  podcastDownloads       PodcastDownload[]
  podcastProgress        PodcastProgress[]
  podcastSubscriptions   PodcastSubscription[]
  spotifyImportJobs      SpotifyImportJob[]
  unavailableAlbums      UnavailableAlbum[]
  discoverConfig         UserDiscoverConfig?
  settings               UserSettings?
}

model UserDiscoverConfig {
  id               String    @id @default(cuid())
  userId           String    @unique
  playlistSize     Int       @default(40)
  maxRetryAttempts Int       @default(3)
  exclusionMonths  Int       @default(6)
  downloadRatio    Float     @default(1.3)
  enabled          Boolean   @default(true)
  lastGeneratedAt  DateTime?
  user             User      @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model UserMoodMix {
  id          String   @id @default(cuid())
  userId      String   @unique
  mood        String
  trackIds    String[]
  coverUrls   String[]
  generatedAt DateTime
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model UserSettings {
  userId          String  @id
  playbackQuality String  @default("original")
  wifiOnly        Boolean @default(false)
  offlineEnabled  Boolean @default(false)
  maxCacheSizeMb  Int     @default(10240)
  user            User    @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model WebhookEvent {
  id            String    @id @default(cuid())
  eventId       String    @unique
  source        String
  eventType     String
  payload       Json
  processed     Boolean   @default(false)
  processedAt   DateTime?
  correlationId String?
  error         String?
  retryCount    Int       @default(0)
  createdAt     DateTime  @default(now())

  @@index([correlationId])
  @@index([createdAt])
  @@index([processed])
  @@index([source, eventType])
}

model PodcastRecommendation {
  id            String   @id @default(cuid())
  podcastId     String
  recommendedId String
  title         String
  author        String?
  description   String?
  coverUrl      String?
  episodeCount  Int      @default(0)
  feedUrl       String?
  itunesId      String?
  score         Float    @default(0)
  cachedAt      DateTime @default(now())
  expiresAt     DateTime

  @@map("podcast_recommendations")
}

model TrackEmbedding {
  track_id      String                @id
  embedding     Unsupported("vector")
  model_version String                @default("laion-clap-music") @db.VarChar(50)
  analyzed_at   DateTime              @default(now()) @db.Timestamptz(6)
  track         Track                 @relation(fields: [track_id], references: [id], onDelete: Cascade)

  @@index([embedding])
  @@index([model_version])
  @@map("track_embeddings")
}

enum AlbumLocation {
  LIBRARY
  DISCOVER
}

enum DiscoverStatus {
  ACTIVE
  LIKED
  MOVED
  DELETED
}

enum ListenSource {
  LIBRARY
  DISCOVERY
  DISCOVERY_KEPT
}
